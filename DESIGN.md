In implementing our project, we took the structure of the finance pset as a starting point. From finance, we kept the login function which redirects users to the home page if the username and password are submitted and if they are correct – otherwise redirecting users to the login page if they reached the route via GET instead of POST. We also kept the logout function which clears the user session and redirects to the login form. We modified the register function to include password requirements in addition to keeping checks such as making sure inputs are not blank and the password matches the password confirmation as well as keeping SQL queries to update the database when a new user registers. Another aspect we kept from finance was the apology.html which will appear if any checks we have implemented do not pass. Lastly, we kept most of helpers.py except for the lookup function.

The rest of this document will focus on the implementation of the rest of our website.

First, we created a new database entitled project.db so that we could begin creating tables that store user inputs. Our first table is called users and has five fields: id, username, hash, cash, and spent. Cash represents the amount of money a user has added to their budget. Spent represents how much money a user has spent. These two fields are set to a default value of 0 to avoid any index errors. The second table is called meals and has five fields: id, cost, user_id, restaurant, and time. This table references the foreign key user_id from the users table. Time also has a default value of CURRENT_TIMESTAMP which automatically tracks when a user inputs logs their meal.

Next, we have a layout.html file which contains information such as bootstrap bundles, javascript components, and the css link in the head and the navbar which we will put on all our subsequent html files using Jinja. If a user is logged in, we will include the full navbar with a logout button. If a user is not logged in, we will include the HarvardEats navbar brand, a register button, and a login button. All of the other html files use Jinja to extend layout.html. Additionally, the navbar contains a dropdown entitled ‘My Eats’ which contains links to all the actions a user can do. This was done with the intention of organizing the site and improving the user experience.

Now, we will go through our implementation in the order that appears in our app.py file, explaining design decisions relevant to a specific function in app.py and its corresponding html files. It has been ordered such that it is similar to the user experience when navigating through our website.

The first function in app.py under anything that we have kept from finance (after_request, register, login, and logout) is our home function which we use to provide functionality to everything in home.html. The homepage links to every other page on the website, which we think increases the convenience of our website. Additionally, there are four cards which are divided based on theme and function.

The first of these is the budget card, which is focused on the financial aspect of our website. This card tells a user what their budget/balance is and how much they have spent. To find the balance, we use SQL to query for the cash of a user, check that a user exists (logs out if not), and then set the balance equal to the actual value of cash by indexing into the table. To find the amount spent, we use SQL to query for the sum of all the costs of the meals a user has logged and set spent equal to the value of the amount spent by indexing into the table. There are two buttons in this card (‘Log a Meal’ and ‘Add Money’) which redirect you to those pages.

The second card on the homepage is focused on a user’s personal stats based on their logged meals. This card tells a user what their favorite restaurant is and what percentile they are across all users based on their spending. The stats card displays a user’s favorite restaurants through SQL and python and Jinja conditionals. The python conditionals check how many distinct restaurants there are, and then saves this so that the HTML can access it to display the favorite restaurants. The HTML conditionals then check the length of this to display their top restaurant if they’ve only been to one, their top two restaurants if they’ve only been to two, and then their top three favorite restaurants if they’ve been to three or more different restaurants, based off of how many times they log a meal from those restaurants. We check these conditionals using SQL commands within app.py. To display the percentile a user is according to their spending, we use SQL and the specific function PERCENT_RANK to find the percentile across all users’ spending and pick the percentile of the current user. We designed it this way to efficiently pull information from our two existing databases and display this information dynamically while ensuring grammatical accuracy. This card also has a ‘Past Meals’ button which redirects users to the corresponding page.

Our third card is the Across Campus card which focuses on the more social aspect of eating. This card displays a pie chart of the most popular restaurants across all users. This is a complement to our Favorite Restaurants section of the Your Stats card, and our hope is that this pie chart allows users to identify restaurants that other users love! The pie chart is rendered through Javascript in HTML and the values are pulled from python which uses SQL to choose the top five restaurants by count of logged meals. All of the other meals eaten at restaurants not in the top five are accounted for in the ‘other’ category of the pie chart. The HTML also has a conditional that displays that there is not enough data if there are less than five total logged meals across all users. One important bug we fixed is that any apostrophes in restaurant names would show up differently when using Jinja in the HTML file and so we made sure to escape when accessing restaurants through Jinja. If you hover over sections of the pie chart, there is a pop-up of the restaurant name and the number of meals eaten there. We did this in order to display a pie chart that is both informative and representative of our users. This card also has a ‘Schedule a Meal’ button which redirects users to the corresponding page.

The fourth card is the Live Feed card which contains a table of the five most recent meals logged by other users. We implemented this through a SQL query. This card is implemented with the intention of showing where other users are spending their money.

Next in app.py, we have the about function which simply redirects the user to the about.html page which explains the reasons we decided to create HarvardEats and introduces the creators.

Next, we have the logmeal function which allows users to log their meals on the Log a Meal page. In logmeal.html, we have a form that allows users to select a restaurant they ate at and input how much their meal cost. Upon submission, this form logs it into the meals database and subtracts the cost from the cash column in the user’s database through SQL. Right now, our form has a set list of options from around Harvard Square where users can start typing to search for their restaurant (or just scroll through the list). We made it a set list of options in order to reduce the variation that comes with user input, such as misspellings, abbreviated names (ex: El Jefe’s vs Jefes, etc.). We have the type to search to make it much more user friendly. We also have conditionals in place to check for correct user input for both restaurant and cost (such as not leaving anything empty, and making sure costs are non-negative). After the meal is logged, we redirect the user to logged.html which displays what they have just logged so they know that their action went through and was recorded correctly.

Next, we have the add function which corresponds to add.html, a page to add money to a user’s account so that they can update their budget as time goes on. It does this through a form that ensures correct user input (no empty fields and positive amounts), and updates the cash column of the user’s account in the users database through a SQL command in app.py.

Next, we have the pastmeals function which obtains the restaurant, cost, and time of each meal the current user has logged through a SQL query. This function redirects the user to pastmeals.html in a table to allow users to see their history of meals.

Lastly, the schedule function redirects users to schedule.html where we embedded When2Meet to make it convenient for people to schedule a meal without leaving our site. We chose to embed because creating our own scheduling functionality was outside the focus of our project, which is budgeting and local food places.